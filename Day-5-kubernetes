# vim pod.yml

apiVersion: v1
kind: Pod
metadata:
 name: pod1
 labels:
   app: webserver
   author: sonal
spec:
 containers:
  - name: c1
    image: httpd
  - name: c2
    image: tomcat


save the file


# kubectl create -f pod.yml

# kubectl get pods
===========================================================


Services in Kubernetes:


Service: 
================
> It is also a resource in Kubernetes
> Allows communication between pods within the cluster or outside the cluster
> exposes the application of the pod to be accessed by a another Pod in the Cluster.
> Exposes the application of the pod to be accessed by an external User outside the Cluster.

Why do we need a Service resource in Kubernetes?

Problems:
=======================
> Pods should not communicate via the pod Ip address as the pod is recreated the pod Ip changes 

> Pod Could not resolve by its name -> you cannot communicate to the pod via its name

> You cannot access the pod outside the cluster -> using its PODIP or using the serviceIP 

Service resource in Kubernetes will help you overcome the Problems
=================================
Service object exposes the application of 1 pod to another pod for communication

3 types of service:
> ClusterIP : It is a service that is created when we want 2 pods to communicate within the cluster

====================================

Create Pod - nginx

# vim pod2.yml


apiVersion: v1
kind: Pod
metadata:
 name: pod2
 labels:
  app: webserver
spec:
 containers:
  - name: c1
    image: nginx

Save the file
===================================

# vim service1.yml

apiVersion: v1
kind: Service
metadata: 
 name: mysvc
spec:
 type: ClusterIP
 selector:
  app: webserver  
 ports:
 - targetPort: 80 
   port: 80  

Save the file

# kubectl create -f pod2.yml

# kubectl create -f service1.yml

# kubectl get pods -o wide

# kubectl get svc

# kubectl get endpoints


# vim testpod.yml

kind: Pod
apiVersion: v1
metadata:
 name: test-pod
spec:
 containers:
  - name: c1
    image: ubuntu
    command: ["bash", "-c", "sleep 6000"]


Save the file

# kubectl create -f testpod.yml

# kubectl get svc

# # kubectl exec -it test-pod -- bash

In the pod install curl

# apt-get update && apt-get install curl -y

# curl mysvc

give exit   => to comeout of the pod


=====================================

Service: Node Port
=============================================
Using this we can access the pod from outside the cluster i.e. from our browser.

By default:
 We cannot access pod ipaddress outside the cluster
 We cannot access the ClusterIP address outside the cluster

So we have to expose the cluster to the outside world.

For this we will create a Service of type NodePort.

A node port is  a new port mapping which is done to the service port

The node port range is 30000 to 32767

Nodeport will be a port number that will be open on every node of the cluster.

# vim service2.yml

apiVersion: v1
kind: Service
metadata: 
 name: mysvc1 
spec:
 type: NodePort
 selector:
  app: webserver  
 ports:
 - targetPort: 80  
   port: 80 



Save the file

# kubectl create -f service2.yml

# kubectl get svc

go to browser and give localhost:<nodeport>


===================================
Deployment:

Creation of replicas -> ReplicaSet
Distribution of replica
Scaling up and scaling down
High availability

==================================

vim deployment.yml

kind: Deployment
apiVersion: apps/v1
metadata:
  name: kubeserve
spec:
  replicas: 3
  minReadySeconds: 10 # wait for 45 sec before going to deploy next pod
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 1  
      maxSurge: 1        # max number of pods to run for the deployment
  selector:
    matchLabels:
      app: kubeserve
  template:
    metadata:
      name: kubeserve
      labels:
        app: kubeserve
    spec:
      containers:
       - name: app
         image: leaddevops/kubeserve:v1


---
kind: Service
apiVersion: v1
metadata:
   name: kubeserve-svc
spec:
  type: NodePort
  ports:
    - port: 80
      targetPort: 80
  selector: 
    app: kubeserve


Save the file

# kubectl create -f deployment.yml

# kubectl get deployment
# kubectl get service
# kubectl get pods
# kubectl scale deployment kubeserve --replicas=5
# kubectl get pods
# kubectl scale deployment kubeserve --replicas=2
Change the Image
# kubectl set image deployment kubeserve app=leaddevops/kubeserve:v2
# kubectl rollout status
# kubectl set image deployment kubeserve app=leaddevops/kubeserve:v3
# kubectl get deployment


ConfigMaps
A ConfigMap is an API object used to store non-confidential data in key-value pairs. Pods can consume ConfigMaps as environment variables, command-line arguments, or as configuration files in a volume.
A ConfigMap allows you to decouple environment-specific configuration from your container images, so that your applications are easily portable.
A ConfigMap is not designed to hold large chunks of data. The data stored in a ConfigMap cannot exceed 1 MiB. If you need to store settings that are larger than this limit, you may want to consider mounting a volume or use a separate database or file service.

ConfigMap does not provide secrecy or encryption. If the data you want to store are confidential, use a Secret rather than a ConfigMap, or use additional (third party) tools to keep your data private.


Demo:
==============

Create 2 configuration file which are storing key and value


# vim dev.properties

app.env: dev
app.mem: 2048
app.url: dev.com

Save the file


# vim prod.properties

app.env: prod
app.mem: 4048
app.url: prod.com

Save the file


Now create 2 different configmaps that store the desired configuration- data

# kubectl create configmap dev-config --from-file=dev.properties

# kubectl describe configmap dev-config

# kubectl create configmap prod-config --from-file=prod.properties

# kubectl describe configmap prod-config

# kubectl get configmap


Now we will create 2 different pods from the same Image that will consume the created configmap.






# vim config-Devpod.yml

apiVersion: v1
kind: Pod
metadata:
 name: dev-pod
spec:
 containers:
  - name: c1
    image: nginx
    volumeMounts:
     - name: config-volume
       mountPath: /etc/config
 volumes:
  - name: config-volume
    configMap:
     name: dev-config



# kubectl create -f config-Devpod.yml

# kubectl exec -it dev-pod -- bash

# cd /etc/config

# ls  ⇒ you will see the dev properties









# vim conf-prodpod.yml

apiVersion: v1
kind: Pod
metadata:
 name: prod-pod
spec:
 containers:
  - name: c1
    image: nginx
    volumeMounts:
     - name: config-volume
       mountPath: /etc/config
 volumes:
  - name: config-volume
    configMap:
     name: prod-config



# kubectl create -f config-prodpod.yml

# kubectl exec -it prod-pod -- bash

# cd /etc/config

# ls  ⇒ you will see the prod properties



Now edit the existing config map for the changes to reflect in container:

#  kubectl edit configmap dev-config -o yaml

It will open a YAMl file.

Press i and make changes to the data

Save the file
Wait for few seconds and then exec into the container

# kubectl exec -it dev-pod -- bash

# cd /etc/config

# cat dev.properties

# exit
