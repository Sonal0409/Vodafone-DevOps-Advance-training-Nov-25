Docker commands:
==============================================================
# docker pull ubuntu

# docker pull ubuntu:20.04

# docker images


Run command options in Docker to create a Container:
==============================================

--name : Give a unique name to the container 

Foreground Mode: (-it)
=====================
i : interactive
t: terminal 

A docker container will created 
Container will be up & Running
User will attached to the terminal of the container

# docker run -it --name cont1 ubuntu

Come out of the container & keep container running - Execute on container : CTL pq

Come out of the container & container should be exited - Execute on container: exit 

Go inside the container : attach to its terminal 

# docker attach <containerid>

# exit 

# docker start containername

# docker stop containername 

====================================================

Attach to the terminal of the container from the host machine:
============================

# docker exec -it <containername> command

# docker exec -it web /bin/bash



Access app running on the Containers from browser of the machine


Port Forwarding OR Port Mapping:
===================================

By default an application on docker container is avaibale on its exposed port.

It is the users internet that cannot reach the container port

For this we have do port forwarding or mapping in docker

i.e. we have to map a VM free system port with container port

example = 8989:80

systemport:containerport

> If a container is already created, we canot do port forwarding for the container

> port forwarding will be applied at the docker run comamnd itself

> flag for port forwarding (-p)

# docker run --name web1 -d -p 8989:80 nginx


> if you want docker to do port mapping then use flag -P

# docker run --name web2 -d -P httpd

==============================================
Demo for python dockerfile
=======================================

# cd

# mkdir mydockerfile1

# cd mydockerfile1

# vim app.py

from flask import Flask 
import os 
app = Flask(__name__) 
@app.route('/') 

def hello(): 
    return ('\nHello from Container World! \n\n')

if __name__ == "__main__": 
    app.run(host="0.0.0.0", port=8080, debug=True)


Save the file

# vim dockerfile

FROM ubuntu:20.04
RUN apt update && apt install python3 -y && apt install python3-flask -y
COPY app.py /tmp
EXPOSE 8080
CMD ["python3", "/tmp/app.py"]


save the file

# docker build -t myimage01 .

# docker run -d -P myimage01

================================================
Multi Stage Build dockerfile
================================================
https://github.com/Sonal0409/multistagebuild-GoLang.git
git clone https://github.com/Sonal0409/multistagebuild-GoLang.git
cd multistagebuild-GoLang
docker build -t myimagegolang .

# docker images


Download docker compose tool:
======================================

On the lab

# sudo su -

Docker compose is already installed.


# docker rm -f $(docker ps -a)

# docker system prune --all

give y  and press enter

# mkdir mycomposefiles && cd mycomposefiles

# vim docker-compose.yml

version: '3'
services:
 db:
  image: mysql:5.7
  restart: always
  environment:
   MYSQL_ROOT_PASSWORD: password
   MYSQL_DATABASE: wordpress
   MYSQL_USER: wordpress
   MYSQL_PASSWORD: wordpress
  networks:
   - wpsite
 phpmyadmin:
  depends_on:
   - db
  image: phpmyadmin/phpmyadmin
  restart: always
  ports:
   - '8181:80'
  environment:
   PMA_HOST: db
   MYSQL_ROOT_PASSWORD: password
  networks:
   - wpsite
 Wordpress:
  depends_on:
   - db
  image: wordpress
  ports:
   - '8000:80'
  restart: always
  environment:
   WORDPRESS_DB_HOST: db:3306
   WORDPRESS_DB_USER: wordpress
   WORDPRESS_DB_PASSWORD: wordpress
   WORDPRESS_DB_NAME: wordpress
  networks:
   - wpsite
networks:
 wpsite:


Save the file.

# docker-compose up -d

# docker-compose ps

========================================================
Kubernetes:
=======================================================

Steps on MASTER NODE:
============================================
# sudo su -

## Install Containerd

sudo wget https://raw.githubusercontent.com/lerndevops/labs/master/scripts/installContainerd.sh -P /tmp
sudo bash /tmp/installContainerd.sh
sudo systemctl restart containerd.service


### Install kubeadm,kubelet,kubectl

You will install these packages on all of your machines:
kubeadm: the command to bootstrap the cluster.
kubelet: the component that runs on all of the machines in your cluster and does things like starting pods and containers.
kubectl: the command line util to talk to your cluster.


sudo wget https://raw.githubusercontent.com/lerndevops/labs/master/scripts/installK8S.sh -P /tmp

sudo bash /tmp/installK8S.sh

## Initialize kubernetes Master Node

   # sudo kubeadm init --ignore-preflight-errors=all

Execute the below commands to setup kubectl and apiserver communication

  mkdir -p $HOME/.kube
  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
  sudo chown $(id -u):$(id -g) $HOME/.kube/config


   ## install networking driver -- Weave/flannel/canal/calico etc...

   ## below installs calico networking driver

   kubectl apply -f https://raw.githubusercontent.com/projectcalico/calico/v3.24.1/manifests/calico.yaml

   # Validate:  kubectl get nodes


Just for your information:



=========================================


Step5 : remove taint form master node of lab

# kubectl taint node ip-172-31-30-173 node-role.kubernetes.io/control-plane:NoSchedule-

Replace with your node name in above command [ run kubectl get nodes to get the node NAME]
